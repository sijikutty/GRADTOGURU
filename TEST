from botocore.exceptions import ClientError
import boto3

from datetime import datetime
import oracledb
import urllib3
import json
import socket

def get_testcase(s3bucket, filename):
    try:
        # Getting the testcase file content
        s3_client = boto3.client("s3")
        
        # Getting the file
        response = s3_client.get_object(Bucket=s3bucket, Key=filename)

        # Reading the file content
        file_content = None        
        file_content = response['Body'].read().decode('utf-8')

        # Converting to JSON
        json_content = json.loads(file_content)
        return json_content
    
    except ClientError as err:
        print(err)


def check_ec2_status(instanceid):
    try:
        client = boto3.client("ec2")

        print(f"Verifying instance {instanceid}")
        response = client.describe_instance_status(InstanceIds=[instanceid])
        
        status = response['InstanceStatuses'][0]    
        print(status)

        if 'running' in status['InstanceState'].values():               # Verifies that the instance's operating system is accepting traffic.
            print("Instance is running")

            if status["InstanceStatus"]["Status"].lower() == "ok":      # Verifies that the instance is reachable. Amazon EC2 tests that network packets can get to the instance.
                print("Instance status : OK")
                return True
            
        return False
    
    except ClientError as err:
        print(err)
        return False
    

def get_DBsecrets(secretID):

    print(f"Secret ID - {secretID}")

    secretmanagerclient = boto3.client("secretsmanager", region_name="us-east-1")

    response = secretmanagerclient.get_secret_value(SecretId=secretID)
    secret = json.loads(response['SecretString'])

    db_secrets = {
        'username'    : secret['username'],
        'password'    : secret['password'],
        'host'        : secret['host'],
        'port'        : secret['port'],
        'servicename' : secret['dbname'],
    }
     
    return db_secrets


def connect_to_oracleDB(secretID):    
    db_secrets = get_DBsecrets(secretID)

    try:
        print("Connecting to DB")
        connection = oracledb.connect(user = db_secrets['username'],
                            password= db_secrets['password' ],
                            host= db_secrets['host'],
                            port= db_secrets['port'], 
                            service_name=db_secrets['servicename'])
        
        print(f"Database connected successfully", connection)
        return {"status":True, "conn":connection}

    except oracledb.Error as e:
        print(f"ORACLE Error: ", str(e)) 
        return {"status":False, "error":str(e)}


def check_onprem_server(url):
    try:
        print(url)
        http = urllib3.PoolManager()
        respose = http.request('GET', url)
        status = respose.status

        print(f"STATUS - {url} : ", status)

        response = {'status' : status == 200, 'response_code' : status }
        return response
    
    except Exception as e:
        response = {'status' : False, 'error' : e}
        return response
    

def check_unix_server(hostname, port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((hostname, port))
        
        response = {'status' : True}
        return response

    except Exception as e:
        response = {'status' : False, 'error' : e }
        return response


def upload_rallyjson_to_s3(s3bucket, filename, payload):
    try:
        s3 = boto3.client('s3')
        
        # Download existing rally payload to lambda tmp folder
        temp_file = r'/tmp/rally_tc_results.json' 
        s3.download_file(Bucket=s3bucket, Key=filename, Filename=temp_file)

        # Overwrite old content with new rally payload
        with open(temp_file, 'r+') as file:
            file.truncate(0)

            for line in payload:
                file.write(f"{line}\n")
            
        # Uploading the updated file from tmp location to s3
        s3.upload_file(temp_file, s3bucket, filename) 

    except ClientError as e:
        raise Exception("boto3 client error in uploadResponse_S3: " + e.__str__())

    except Exception as e:
        raise Exception("Unexpected error in uploadResponse_S3: " + e.__str__())    
    

def lambda_handler(event, context):

    # Getting 'testcase.json' from s3
    TCjson_s3bucket = "app-5208-dev-ue1-shared-s3-1"
    TCjson_filename = "Testing/Data/PSTesting/testcase.json"
    input_payload   = get_testcase(TCjson_s3bucket, TCjson_filename)

    print(input_payload)

    rallyjson_list = []

    for tc in input_payload["testcases"]:

        # Skipping all tests other than AWS_Infra in the testcase.json file
        if "smoketest aws_infra" not in tc["key"].lower():
            continue                    

        # Skipping tests where runflag is not set to 'Y'
        if tc["runflag"].lower() != "y":
            continue                    

        # Initializing rally verdict and notes
        verdict = "Pass"
        notes = ''
        
        # -------------------- Verifying EC2 instances -----------------------------
        
        if tc["scenario"].lower().endswith("ec2_instances"):

            print(f"---------- {tc['scenario']} --------------")

            not_running = []
            ec2_instances   = tc["ec2_instances"].values()

            for instance in ec2_instances:
                is_running = check_ec2_status(instance)
                print(is_running) 

                if not is_running:
                    verdict = "Fail"
                    not_running.append(instance)

            if len(not_running) > 0:
                notes = f"The following instance(s) are not running as expected : {', '.join(not_running)}."


        # --------------------- Verifying DB connectivity -----------------------------
        
        elif tc["scenario"].lower().endswith("db_connectivity"):

            print(f"---------- {tc['scenario']} --------------")

            for db, secret_id in tc['db_secret'].items():
                response = connect_to_oracleDB(secret_id)

                if response['status'] == True:
                    print(response['conn'])
                    notes = notes + f'{db} connected successfully'
            
                else:
                    verdict = "Fail"
                    notes = notes + f'{db} connection failed.' + response['error']

        # --------------------- Verifying OnPrem Servers -----------------------------

        elif tc["scenario"].lower().endswith("onprem_server"):

            print(f"---------- {tc['scenario']} --------------")

            if 'unix' in tc['scenario']:
                response = check_unix_server(tc["server"], tc["port_number"])

            else:
                response = check_onprem_server(url=tc['server'])

            print("Server Status : ", response)

            if not response["status"]:
                verdict = 'Fail'
                notes = f"Server {tc['server']} is unable to reach at the moment. {response['error']}"

        else:
            continue

        # ---------------------- Writing TC Results to Rally -----------------------------

        print("Verdict:", verdict)

        # Fetching cloud watch details for MS Teams Integration
        cloud_group=context.log_group_name
        cloud_stream=context.log_stream_name
        cloudwatch_details = f"Cloudwatch Group : {cloud_group} and Cloud logstream : {cloud_stream}"

        notes = f"The testcase {tc['scenario']} has {verdict}ed. \n" + notes + cloudwatch_details
        print(notes)

        rally_secrets = input_payload["rally"]

        # Replacing " with whitespace to avoid rallyIntegration lambda failure while parsing
        notes = notes.replace("\"", "")

        rallyjson = {  
            "key": tc['key'],

            "Rally": {
                "server"    : rally_secrets['server'], 
                "user"      : rally_secrets['user'], 
                "apikey"	: rally_secrets['apikey'], 
                "workspace"	: rally_secrets['workspace'],
                "project"   : rally_secrets['project'],
                "Tcid"      : tc['key'].split("-")[-1].strip(),
                "build"     : f"{tc['env']}-Automated Run", 
                "run_date"  : datetime.now().isoformat(), 
                "verdict"   : verdict,
                "notes"     : notes
            }
        } 

        print(rallyjson)
        rallyjson_list.append(rallyjson)

    # Checking if rally_secrets is already declared 
    # If atleast one of the testcases in testcase.json matches any of the above if conditions rally_secrets will be declared
    if "rally_secrets" in locals():
        rallys3 = rally_secrets['s3bucket']
        rallyinputfile = rally_secrets['inputfile']

        upload_rallyjson_to_s3(s3bucket=rallys3, filename=rallyinputfile, payload=rallyjson_list)

        return True
---------
from playwright.sync_api import Page, expect
from automation_utils import get_testdata, get_secrets,construct_putty_credentials,save_credentials
from smoketest_awsinfra import get_testcase,connect_to_oracleDB
import pytest
import boto3
import sys
from botocore.exceptions import ClientError

@pytest.mark.parametrize("testcase", get_testdata("test_PS_EGL_DB_connectivity"))
def test_PS_EGL_DB_connectivity(page:Page, testcase):

    testdata = testcase["testdata"]
    connect_to_oracleDB(testdata["secretID"])
